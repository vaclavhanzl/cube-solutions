<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Brick Viewer (Final Tuning)</title>
  <style>
    html, body {
      margin: 0;
      overflow: hidden;
      height: 100%;
      background: white;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
<script type="module">
  import * as THREE from 'https://esm.sh/three@0.155.0';
  import { TrackballControls } from 'https://esm.sh/three@0.155.0/examples/jsm/controls/TrackballControls.js';
  import { OBJLoader } from 'https://esm.sh/three@0.155.0/examples/jsm/loaders/OBJLoader.js';

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(8, 5, 10);  // ✅ Better 3D angle

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor('white');
  document.body.appendChild(renderer.domElement);

  const controls = new TrackballControls(camera, renderer.domElement);
  controls.target.set(2, 2, 2);  // ✅ Rotate around this point
  controls.rotateSpeed = 5.0;    // ✅ 5x more sensitive rotation
  controls.zoomSpeed = 1.2;
  controls.panSpeed = 0.8;
  controls.update();

  scene.add(new THREE.AmbientLight(0xffffff, 0.6));
  const light = new THREE.DirectionalLight(0xffffff, 0.6);
  light.position.set(5, 10, 7.5);
  scene.add(light);

  const colors = [
    'red', 'green', 'orange', 'gray', 'blue', 'bisque', 'azure', 'coral',
    'aquamarine', 'cadetblue', 'cyan', 'khaki', 'magenta', 'lightgray', 'blue', 'red'
  ];

  const loader = new OBJLoader();
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();
  const brickMeshes = [];

  const urlParams = new URLSearchParams(window.location.search);
  const brickList = urlParams.get("bricks") || "";
  const brickIds = brickList.split(",").map(s => s.trim()).filter(Boolean);

  brickIds.forEach((item, index) => {
    const id = item.startsWith("-") ? item.slice(1) : item;
    const path = `bricks/${id}.obj`;
    const startTransparent = item.startsWith("-");

    loader.load(path, (obj) => {
      const color = colors[index % colors.length];

      obj.traverse(child => {
        if (child.isMesh) {
          child.material = new THREE.MeshPhongMaterial({
            color,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: startTransparent ? 0.02 : 1.0,
            depthWrite: !startTransparent
          });
        }
      });

      obj.name = `brick-${id}`;
      obj.userData.transparent = startTransparent;
      scene.add(obj);
      brickMeshes.push(obj);
    });
  });

  window.addEventListener('mousedown', event => {
    const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(brickMeshes, true);

    if (intersects.length > 0) {
      const mesh = intersects[0].object;
      const root = mesh.parent;
      const makeTransparent = !root.userData.transparent;
      root.userData.transparent = makeTransparent;

      root.traverse(child => {
        if (child.isMesh && child.material) {
          child.material.opacity = makeTransparent ? 0.02 : 1.0;
          child.material.depthWrite = !makeTransparent;
        }
      });
    }
  });

  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
  }
  animate();

  window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    controls.handleResize();
  });
</script>
</body>
</html>
